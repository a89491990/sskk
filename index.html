<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡¶Æ‡¶∞‡ßã - ‡¶ü‡ßç‡¶∞‡¶™‡¶ø‡¶ï‡ßç‡¶Ø‡¶æ‡¶≤ ‡¶ó‡ßã‡¶≤‡ßá‡¶Æ ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡¶ø‡¶Ø‡¶º‡¶∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
        }
        
        /* HUD ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ */
        #hud {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .health-container {
            margin-bottom: 20px;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,215,0,0.3);
            width: 300px;
        }
        
        .health-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .health-bar-bg {
            width: 100%;
            height: 25px;
            background: rgba(0,0,0,0.6);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #ffd700;
            box-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8888, #ff4444);
            background-size: 200% 100%;
            animation: healthPulse 2s infinite;
            transition: width 0.3s ease;
        }
        
        #enemy-health-fill {
            background: linear-gradient(90deg, #ff4444, #ff6b6b, #ff4444);
            background-size: 200% 100%;
        }
        
        @keyframes healthPulse {
            0% { background-position: 0% 0%; }
            50% { background-position: 100% 0%; }
            100% { background-position: 0% 0%; }
        }
        
        #crystal-panel {
            position: absolute;
            bottom: 40px;
            left: 40px;
            background: rgba(0,0,0,0.5);
            padding: 20px 30px;
            border-radius: 60px;
            border: 2px solid #9c27b0;
            box-shadow: 0 0 30px rgba(156,39,176,0.5);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }
        
        #crystal-value {
            color: #ffd700;
            font-size: 32px;
            text-shadow: 0 0 20px #9c27b0;
        }
        
        #controls-panel {
            position: absolute;
            bottom: 40px;
            right: 40px;
            background: rgba(0,0,0,0.5);
            padding: 25px;
            border-radius: 30px;
            border: 1px solid rgba(255,215,0,0.5);
            backdrop-filter: blur(10px);
            color: white;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 12px 0;
            font-size: 18px;
        }
        
        .key {
            background: rgba(255,215,0,0.2);
            border: 2px solid #ffd700;
            padding: 8px 15px;
            border-radius: 12px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            box-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        
        #combo-display {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 30px #ff6b00, 0 0 60px #ff0000;
            z-index: 100;
            white-space: nowrap;
            animation: comboPop 0.5s ease;
        }
        
        @keyframes comboPop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        
        #damage-number {
            position: absolute;
            color: #ff4444;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000;
            z-index: 150;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }
        
        @keyframes damageFloat {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1.5); opacity: 0; }
        }
        
        #gameover {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 50px 100px;
            border-radius: 40px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 100px rgba(255,215,0,0.5);
            color: white;
            font-size: 64px;
            font-weight: bold;
            text-align: center;
            z-index: 200;
            display: none;
            backdrop-filter: blur(20px);
            animation: gameoverPop 0.5s ease;
        }
        
        @keyframes gameoverPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        #gameover button {
            margin-top: 30px;
            padding: 15px 50px;
            font-size: 28px;
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
            transition: transform 0.3s;
            box-shadow: 0 0 30px #ffd700;
        }
        
        #gameover button:hover {
            transform: scale(1.1);
        }
        
        #victory-text {
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <!-- HUD ‡¶è‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶∏ -->
    <div id="hud">
        <div class="health-container">
            <div class="health-label">
                <span>‚öîÔ∏è ‡¶Æ‡¶∞‡ßã</span>
                <span id="player-health-value">100/100</span>
            </div>
            <div class="health-bar-bg">
                <div id="player-health-fill" class="health-fill"></div>
            </div>
        </div>
        
        <div class="health-container">
            <div class="health-label">
                <span>üëæ ‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶ó‡ßã‡¶≤‡ßá‡¶Æ</span>
                <span id="enemy-health-value">100/100</span>
            </div>
            <div class="health-bar-bg">
                <div id="enemy-health-fill" class="health-fill"></div>
            </div>
        </div>
    </div>
    
    <div id="crystal-panel">
        <span>üíé ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞</span>
        <span id="crystal-value">100%</span>
    </div>
    
    <div id="controls-panel">
        <h3 style="color: #ffd700; margin-top: 0; text-align: center;">üéÆ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤</h3>
        <div class="control-item">
            <span class="key">WASD</span>
            <span>‡¶Æ‡ßÅ‡¶≠‡¶Æ‡ßá‡¶®‡ßç‡¶ü</span>
        </div>
        <div class="control-item">
            <span class="key">Space</span>
            <span>‡¶ú‡¶æ‡¶Æ‡ßç‡¶™</span>
        </div>
        <div class="control-item">
            <span class="key">J</span>
            <span>‡¶≤‡¶æ‡¶á‡¶ü ‡¶™‡¶æ‡¶û‡ßç‡¶ö</span>
        </div>
        <div class="control-item">
            <span class="key">K</span>
            <span>‡¶π‡ßá‡¶≠‡¶ø ‡¶™‡¶æ‡¶û‡ßç‡¶ö</span>
        </div>
        <div class="control-item">
            <span class="key">L</span>
            <span>‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶¨‡ßç‡¶≤‡¶æ‡¶∏‡ßç‡¶ü</span>
        </div>
        <div class="control-item">
            <span class="key">Mouse</span>
            <span>‡¶ï‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶∞‡¶æ</span>
        </div>
    </div>
    
    <div id="combo-display"></div>
    
    <div id="gameover">
        <div id="victory-text">‡¶¨‡¶ø‡¶ú‡¶Ø‡¶º‡ßÄ</div>
        <div>‚ö° ‡¶Æ‡¶∞‡ßã ‚ö°</div>
        <button onclick="location.reload()">‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ñ‡ßá‡¶≤‡ßÅ‡¶®</button>
    </div>

    <!-- Three.js ‡¶è‡¶¨‡¶Ç ‡¶≤‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∞‡¶ø -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        
        // ‡¶∏‡¶ø‡¶® ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        
        // ‡¶ï‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶∞‡¶æ
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 12);
        
        // ‡¶∞‡ßá‡¶®‡ßç‡¶°‡¶æ‡¶∞‡¶æ‡¶∞
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        
        // ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤‡¶∏
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 2, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.enablePan = false;
        
        // ‡¶≤‡¶æ‡¶á‡¶ü‡¶ø‡¶Ç ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ
        // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶Æ‡ßç‡¶¨‡¶ø‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡¶æ‡¶á‡¶ü
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        
        // ‡¶Æ‡ßÇ‡¶≤ ‡¶∏‡ßÇ‡¶∞‡ßç‡¶Ø‡ßá‡¶∞ ‡¶Ü‡¶≤‡ßã
        const sunLight = new THREE.DirectionalLight(0xfff5d1, 1.5);
        sunLight.position.set(10, 20, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -15;
        sunLight.shadow.camera.right = 15;
        sunLight.shadow.camera.top = 15;
        sunLight.shadow.camera.bottom = -15;
        scene.add(sunLight);
        
        // ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶≤‡¶æ‡¶á‡¶ü
        const backLight = new THREE.DirectionalLight(0x4466ff, 0.8);
        backLight.position.set(-5, 5, -10);
        scene.add(backLight);
        
        // ‡¶∞‡¶ø‡¶Æ ‡¶≤‡¶æ‡¶á‡¶ü
        const rimLight = new THREE.DirectionalLight(0xffaa88, 0.6);
        rimLight.position.set(-5, 5, 10);
        scene.add(rimLight);
        
        // ‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶≤‡¶æ‡¶á‡¶ü (‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)
        const crystalLight = new THREE.PointLight(0x9c27b0, 2, 10);
        crystalLight.position.set(0, 2, 0);
        scene.add(crystalLight);
        
        // ‡¶≠‡¶≤‡¶ø‡¶â‡¶Æ‡ßá‡¶ü‡ßç‡¶∞‡¶ø‡¶ï ‡¶≤‡¶æ‡¶á‡¶ü ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü
        const lightHelper = new THREE.DirectionalLightHelper(sunLight, 1);
        // scene.add(lightHelper);
        
        // ** ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° - ‡¶ü‡ßç‡¶∞‡¶™‡¶ø‡¶ï‡ßç‡¶Ø‡¶æ‡¶≤ ‡¶™‡ßç‡¶Ø‡¶æ‡¶∞‡¶æ‡¶°‡¶æ‡¶á‡¶∏ **
        
        // ‡¶Ü‡¶ï‡¶æ‡¶∂ (‡¶ó‡ßç‡¶∞‡ßá‡¶°‡¶ø‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü)
        const skyGeo = new THREE.SphereGeometry(100, 32, 16);
        const skyMat = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);
        
        // ‡¶Æ‡ßá‡¶ò
        function createCloud(x, y, z, scale) {
            const group = new THREE.Group();
            
            const cloudMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0x444444,
                transparent: true,
                opacity: 0.8
            });
            
            const parts = [
                { pos: [0,0,0], scale: [1.5,0.6,0.8] },
                { pos: [1.2,0.2,0.3], scale: [1.2,0.5,0.6] },
                { pos: [-1.2,0.1,-0.2], scale: [1.2,0.5,0.6] },
                { pos: [0.5,0.4,0.8], scale: [1.0,0.4,0.5] },
                { pos: [-0.5,0.3,-0.8], scale: [1.0,0.4,0.5] }
            ];
            
            parts.forEach(part => {
                const geo = new THREE.SphereGeometry(1, 8, 8);
                const mesh = new THREE.Mesh(geo, cloudMat);
                mesh.scale.set(part.scale[0], part.scale[1], part.scale[2]);
                mesh.position.set(part.pos[0], part.pos[1], part.pos[2]);
                mesh.castShadow = false;
                mesh.receiveShadow = false;
                group.add(mesh);
            });
            
            group.position.set(x, y, z);
            group.scale.set(scale, scale, scale);
            return group;
        }
        
        // ‡¶Æ‡ßá‡¶ò ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ
        scene.add(createCloud(-10, 8, -15, 2));
        scene.add(createCloud(5, 10, -20, 2.5));
        scene.add(createCloud(15, 7, -10, 1.8));
        scene.add(createCloud(-15, 9, 10, 2.2));
        scene.add(createCloud(0, 11, 15, 2));
        
        // ** ‡¶ì‡¶∂‡¶æ‡¶® **
        const oceanGeo = new THREE.CylinderGeometry(30, 30, 0.5, 64);
        const oceanMat = new THREE.MeshStandardMaterial({ 
            color: 0x1e88e5,
            emissive: 0x0a3d62,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const ocean = new THREE.Mesh(oceanGeo, oceanMat);
        ocean.position.y = -0.3;
        ocean.receiveShadow = true;
        scene.add(ocean);
        
        // ‡¶ì‡¶∂‡¶æ‡¶® ‡¶ì‡¶Ø‡¶º‡ßá‡¶≠ ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü (‡¶õ‡ßã‡¶ü ‡¶õ‡ßã‡¶ü ‡¶ó‡ßã‡¶≤‡¶ï)
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const radius = 12 + Math.sin(i * 5) * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const waveGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 6);
            const waveMat = new THREE.MeshStandardMaterial({ 
                color: 0x4fc3f7, 
                transparent: true, 
                opacity: 0.4,
                emissive: 0x1565c0
            });
            const wave = new THREE.Mesh(waveGeo, waveMat);
            wave.position.set(x, -0.2 + Math.sin(i) * 0.1, z);
            wave.castShadow = false;
            wave.receiveShadow = false;
            scene.add(wave);
        }
        
        // ** ‡¶Ü‡¶á‡¶≤‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶° **
        const islandGeo = new THREE.ConeGeometry(10, 2, 32);
        const islandMat = new THREE.MeshStandardMaterial({ 
            color: 0xf4a460,
            roughness: 0.6,
            emissive: 0x8b5a2b
        });
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.position.y = 0;
        island.receiveShadow = true;
        island.castShadow = true;
        scene.add(island);
        
        // ‡¶ò‡¶æ‡¶∏
        for (let i = 0; i < 200; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 6;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const grassGeo = new THREE.ConeGeometry(0.1, 0.3, 4);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.position.set(x, 0.15, z);
            grass.castShadow = true;
            grass.receiveShadow = true;
            scene.add(grass);
        }
        
        // ‡¶´‡ßÅ‡¶≤
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 4 + Math.random() * 5;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const flowerGeo = new THREE.SphereGeometry(0.1, 6);
            const flowerMat = new THREE.MeshStandardMaterial({ color: 0xff69b4 });
            const flower = new THREE.Mesh(flowerGeo, flowerMat);
            flower.position.set(x, 0.15, z);
            flower.castShadow = true;
            flower.receiveShadow = true;
            scene.add(flower);
        }
        
        // ** ‡¶™‡¶æ‡¶Æ ‡¶ó‡¶æ‡¶õ **
        function createPalmTree(x, z, size = 1) {
            const group = new THREE.Group();
            
            // ‡¶ï‡¶æ‡¶£‡ßç‡¶°
            const trunkGeo = new THREE.CylinderGeometry(0.5 * size, 0.8 * size, 4 * size, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2 * size;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            group.add(trunk);
            
            // ‡¶™‡¶æ‡¶§‡¶æ (‡¶¨‡¶°‡¶º)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const leafGeo = new THREE.ConeGeometry(0.8 * size, 2 * size, 6);
                const leafMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.position.set(
                    Math.cos(angle) * 1.5 * size,
                    4 * size,
                    Math.sin(angle) * 1.5 * size
                );
                leaf.rotation.x = 0.4;
                leaf.rotation.z = angle;
                leaf.castShadow = true;
                leaf.receiveShadow = true;
                group.add(leaf);
                
                // ‡¶õ‡ßã‡¶ü ‡¶™‡¶æ‡¶§‡¶æ
                const smallLeafGeo = new THREE.ConeGeometry(0.4 * size, 1.2 * size, 6);
                const smallLeaf = new THREE.Mesh(smallLeafGeo, leafMat);
                smallLeaf.position.set(
                    Math.cos(angle) * 2.2 * size,
                    4.5 * size,
                    Math.sin(angle) * 2.2 * size
                );
                smallLeaf.rotation.x = 0.6;
                smallLeaf.rotation.z = angle + 0.3;
                smallLeaf.castShadow = true;
                smallLeaf.receiveShadow = true;
                group.add(smallLeaf);
            }
            
            // ‡¶®‡¶æ‡¶∞‡¶ø‡¶ï‡ßá‡¶≤
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const coconutGeo = new THREE.SphereGeometry(0.3 * size, 8);
                const coconutMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const coconut = new THREE.Mesh(coconutGeo, coconutMat);
                coconut.position.set(
                    Math.cos(angle) * 0.8 * size,
                    2.5 * size,
                    Math.sin(angle) * 0.8 * size
                );
                coconut.castShadow = true;
                coconut.receiveShadow = true;
                group.add(coconut);
            }
            
            group.position.set(x, 0, z);
            return group;
        }
        
        // ‡¶ó‡¶æ‡¶õ ‡¶¨‡¶∏‡¶æ‡¶®‡ßã
        scene.add(createPalmTree(-7, -7, 1.2));
        scene.add(createPalmTree(7, -7, 1.3));
        scene.add(createPalmTree(-7, 7, 1.1));
        scene.add(createPalmTree(7, 7, 1.4));
        scene.add(createPalmTree(-8, 0, 1.0));
        scene.add(createPalmTree(8, 2, 1.1));
        scene.add(createPalmTree(2, -8, 1.2));
        scene.add(createPalmTree(-2, 8, 1.3));
        
        // ‡¶™‡¶æ‡¶•‡¶∞
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 4;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const rockGeo = new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.4);
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, 0.2, z);
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }
        
        // ** ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶∂‡¶® **
        
        // ‡¶∞‡ßã‡¶¨‡¶ü ‡¶Ü‡¶∞‡ßç‡¶Æ (‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶°)
        function createDetailedArm(side, color, isEnemy = false) {
            const group = new THREE.Group();
            
            // ‡¶ï‡¶æ‡¶Å‡¶ß‡ßá‡¶∞ ‡¶Ü‡¶∞‡ßç‡¶Æ‡¶∞
            const shoulderGeo = new THREE.SphereGeometry(0.45, 16);
            const shoulderMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.3, metalness: 0.7 });
            const shoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            shoulder.position.y = 0.2;
            shoulder.castShadow = true;
            shoulder.receiveShadow = true;
            group.add(shoulder);
            
            // ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶¨‡¶æ‡¶π‡ßÅ (‡¶ß‡¶æ‡¶§‡¶¨)
            const upperArmGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.3, 8);
            const upperArmMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.3 });
            const upperArm = new THREE.Mesh(upperArmGeo, upperArmMat);
            upperArm.position.y = -0.45;
            upperArm.castShadow = true;
            upperArm.receiveShadow = true;
            group.add(upperArm);
            
            // ‡¶ï‡¶®‡ßÅ‡¶á ‡¶ú‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü
            const elbowGeo = new THREE.SphereGeometry(0.3, 12);
            const elbowMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });
            const elbow = new THREE.Mesh(elbowGeo, elbowMat);
            elbow.position.y = -1.1;
            elbow.castShadow = true;
            elbow.receiveShadow = true;
            group.add(elbow);
            
            // ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¨‡¶æ‡¶π‡ßÅ
            const lowerArmGeo = new THREE.CylinderGeometry(0.25, 0.2, 1.1, 8);
            const lowerArmMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const lowerArm = new THREE.Mesh(lowerArmGeo, lowerArmMat);
            lowerArm.position.y = -1.7;
            lowerArm.castShadow = true;
            lowerArm.receiveShadow = true;
            group.add(lowerArm);
            
            // ‡¶Æ‡ßÅ‡¶†‡¶ø (‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶°)
            const fistGroup = new THREE.Group();
            
            const fistBaseGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const fistBaseMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5 });
            const fistBase = new THREE.Mesh(fistBaseGeo, fistBaseMat);
            fistBase.castShadow = true;
            fistBase.receiveShadow = true;
            fistGroup.add(fistBase);
            
            // ‡¶Ü‡¶ô‡ßç‡¶ó‡ßÅ‡¶≤
            for (let i = 0; i < 4; i++) {
                const fingerGeo = new THREE.BoxGeometry(0.1, 0.2, 0.1);
                const fingerMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.4 });
                const finger = new THREE.Mesh(fingerGeo, fingerMat);
                finger.position.set(
                    (i % 2 === 0 ? -0.15 : 0.15),
                    0.1,
                    -0.1 - (i * 0.1)
                );
                finger.castShadow = true;
                finger.receiveShadow = true;
                fistGroup.add(finger);
            }
            
            fistGroup.position.y = -2.3;
            group.add(fistGroup);
            
            return group;
        }
        
        // ‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶° ‡¶∞‡ßã‡¶¨‡¶ü
        function createDetailedRobot(isEnemy = false) {
            const group = new THREE.Group();
            
            const mainColor = isEnemy ? 0x8B4513 : 0xCD853F;
            const accentColor = isEnemy ? 0x696969 : 0xA9A9A9;
            const crystalColor = isEnemy ? 0xFF4444 : 0x9C27B0;
            
            // ‡¶¨‡¶°‡¶ø (‡¶Æ‡ßá‡¶á‡¶®)
            const bodyGeo = new THREE.CylinderGeometry(1.0, 1.2, 2.2, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: mainColor, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.1;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);
            
            // ‡¶¨‡¶°‡¶ø ‡¶Ü‡¶∞‡ßç‡¶Æ‡¶∞
            const armorGeo = new THREE.BoxGeometry(1.4, 1.0, 0.6);
            const armorMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.6, roughness: 0.3 });
            const armor = new THREE.Mesh(armorGeo, armorMat);
            armor.position.set(0, 1.3, 0.5);
            armor.castShadow = true;
            armor.receiveShadow = true;
            group.add(armor);
            
            // ‡¶ï‡¶æ‡¶Å‡¶ß‡ßá‡¶∞ ‡¶™‡ßç‡¶Ø‡¶æ‡¶°
            const shoulderPadGeo = new THREE.SphereGeometry(0.5, 8);
            const shoulderPadMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.7 });
            
            const leftPad = new THREE.Mesh(shoulderPadGeo, shoulderPadMat);
            leftPad.position.set(-0.9, 1.7, 0);
            leftPad.scale.set(0.8, 0.4, 0.6);
            leftPad.castShadow = true;
            leftPad.receiveShadow = true;
            group.add(leftPad);
            
            const rightPad = new THREE.Mesh(shoulderPadGeo, shoulderPadMat);
            rightPad.position.set(0.9, 1.7, 0);
            rightPad.scale.set(0.8, 0.4, 0.6);
            rightPad.castShadow = true;
            rightPad.receiveShadow = true;
            group.add(rightPad);
            
            // ‡¶π‡ßá‡¶° (‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤‡¶°)
            const headGeo = new THREE.SphereGeometry(0.7, 24);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.3 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);
            
            // ‡¶´‡ßá‡¶∏ ‡¶™‡ßç‡¶≤‡ßá‡¶ü
            const faceGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8);
            const faceMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.set(0, 2.4, 0.5);
            face.rotation.x = 0.2;
            face.castShadow = true;
            face.receiveShadow = true;
            group.add(face);
            
            // ‡¶ö‡ßã‡¶ñ (LED)
            const eyeGeo = new THREE.SphereGeometry(0.15, 8);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x00FFFF, emissive: 0x004444 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.25, 2.5, 0.7);
            leftEye.castShadow = true;
            leftEye.receiveShadow = true;
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.25, 2.5, 0.7);
            rightEye.castShadow = true;
            rightEye.receiveShadow = true;
            group.add(rightEye);
            
            // ‡¶∏‡ßç‡¶ü‡ßç‡¶∞ ‡¶π‡ßç‡¶Ø‡¶æ‡¶ü
            const hatBaseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.2, 8);
            const hatBaseMat = new THREE.MeshStandardMaterial({ color: 0xF4A460 });
            const hatBase = new THREE.Mesh(hatBaseGeo, hatBaseMat);
            hatBase.position.y = 2.8;
            hatBase.castShadow = true;
            hatBase.receiveShadow = true;
            group.add(hatBase);
            
            const hatTopGeo = new THREE.ConeGeometry(0.8, 0.8, 8);
            const hatTopMat = new THREE.MeshStandardMaterial({ color: 0xCD853F });
            const hatTop = new THREE.Mesh(hatTopGeo, hatTopMat);
            hatTop.position.y = 3.2;
            hatTop.castShadow = true;
            hatTop.receiveShadow = true;
            group.add(hatTop);
            
            // ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ (‡¶ó‡ßç‡¶≤‡ßã‡¶Ø‡¶º‡¶ø‡¶Ç)
            const crystalGeo = new THREE.OctahedronGeometry(0.4);
            const crystalMat = new THREE.MeshStandardMaterial({ 
                color: crystalColor, 
                emissive: crystalColor,
                roughness: 0.2,
                metalness: 0.3
            });
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.set(0, 1.3, 0.9);
            crystal.castShadow = true;
            crystal.receiveShadow = true;
            group.add(crystal);
            
            // ‡¶π‡¶æ‡¶§
            const leftArm = createDetailedArm('left', mainColor, isEnemy);
            leftArm.position.set(-1.2, 1.6, 0);
            leftArm.rotation.z = 0.2;
            group.add(leftArm);
            
            const rightArm = createDetailedArm('right', mainColor, isEnemy);
            rightArm.position.set(1.2, 1.6, 0);
            rightArm.rotation.z = -0.2;
            group.add(rightArm);
            
            // ‡¶™‡¶æ
            const legGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.4, 8);
            const legMat = new THREE.MeshStandardMaterial({ color: mainColor });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.6, 0.2, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.6, 0.2, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            group.add(rightLeg);
            
            // ‡¶™‡¶æ‡¶Ø‡¶º‡ßá‡¶∞ ‡¶™‡¶æ‡¶§‡¶æ
            const footGeo = new THREE.BoxGeometry(0.6, 0.2, 0.8);
            const footMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.5 });
            
            const leftFoot = new THREE.Mesh(footGeo, footMat);
            leftFoot.position.set(-0.6, -0.1, 0.2);
            leftFoot.castShadow = true;
            leftFoot.receiveShadow = true;
            group.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeo, footMat);
            rightFoot.position.set(0.6, -0.1, 0.2);
            rightFoot.castShadow = true;
            rightFoot.receiveShadow = true;
            group.add(rightFoot);
            
            return group;
        }
        
        // ‡¶™‡ßç‡¶≤‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ì ‡¶è‡¶®‡¶ø‡¶Æ‡¶ø ‡¶§‡ßà‡¶∞‡¶ø
        const player = createDetailedRobot(false);
        player.position.set(0, 0.5, 0);
        player.scale.set(1, 1, 1);
        scene.add(player);
        
        const enemy = createDetailedRobot(true);
        enemy.position.set(4, 0.5, 4);
        enemy.scale.set(1, 1, 1);
        scene.add(enemy);
        
        // ‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø‡¶ï‡ßá‡¶≤ ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü
        const particleGeo = new THREE.BufferGeometry();
        const particleCount = 100;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i*3] = (Math.random() - 0.5) * 20;
            positions[i*3+1] = (Math.random() - 0.5) * 10;
            positions[i*3+2] = (Math.random() - 0.5) * 20;
            
            colors[i*3] = Math.random() * 0.5 + 0.5;
            colors[i*3+1] = Math.random() * 0.5;
            colors[i*3+2] = Math.random() * 0.5 + 0.5;
        }
        
        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particleMat = new THREE.PointsMaterial({ 
            size: 0.1, 
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);
        
        // ‡¶ó‡ßá‡¶Æ ‡¶∏‡ßç‡¶ü‡ßá‡¶ü
        let playerHealth = 100;
        let enemyHealth = 100;
        let crystalEnergy = 100;
        let combo = 0;
        let gameActive = true;
        let attackCooldown = false;
        let specialCooldown = false;
        
        // ‡¶ï‡ßÄ ‡¶∏‡ßç‡¶ü‡ßá‡¶ü
        const keys = {
            w: false, a: false, s: false, d: false,
            space: false, j: false, k: false, l: false
        };
        
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }
            if (e.code === 'Space') {
                keys.space = true;
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
                e.preventDefault();
            }
            if (e.code === 'Space') {
                keys.space = false;
                e.preventDefault();
            }
        });
        
        // ‡¶°‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶ú ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
        function showDamageNumber(value, x, y, z, isEnemy = true) {
            const div = document.createElement('div');
            div.id = 'damage-number';
            div.textContent = `-${value}`;
            div.style.left = '50%';
            div.style.top = '50%';
            div.style.color = isEnemy ? '#ff4444' : '#44ff44';
            document.body.appendChild(div);
            
            setTimeout(() => {
                div.remove();
            }, 1000);
        }
        
        // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶ï ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
        function performAttack(damage, type) {
            if (!gameActive || attackCooldown) return;
            
            attackCooldown = true;
            setTimeout(() => attackCooldown = false, 400);
            
            const distance = player.position.distanceTo(enemy.position);
            if (distance < 3.5) {
                enemyHealth -= damage;
                combo++;
                
                showDamageNumber(damage, enemy.position.x, enemy.position.y + 2, enemy.position.z, true);
                
                // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Æ‡ßá‡¶∂‡¶®
                const rightArm = player.children[12]; // ‡¶∞‡¶æ‡¶á‡¶ü ‡¶Ü‡¶∞‡ßç‡¶Æ
                if (rightArm) {
                    rightArm.rotation.x = -1.5;
                    rightArm.rotation.z = -0.8;
                    setTimeout(() => {
                        rightArm.rotation.x = 0;
                        rightArm.rotation.z = -0.2;
                    }, 200);
                }
                
                // ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶´‡ßç‡¶≤‡ßç‡¶Ø‡¶æ‡¶∂
                const crystal = player.children[10];
                if (crystal) {
                    crystal.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        crystal.material.emissive.setHex(0x9c27b0);
                    }, 100);
                }
                
                // ‡¶ï‡¶Æ‡ßç‡¶¨‡ßã ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
                document.getElementById('combo-display').textContent = `‚ö° ${combo}x COMBO!`;
                setTimeout(() => {
                    document.getElementById('combo-display').textContent = '';
                }, 1000);
                
                // ‡¶π‡ßá‡¶≤‡¶• ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
                document.getElementById('enemy-health-fill').style.width = Math.max(0, enemyHealth) + '%';
                document.getElementById('enemy-health-value').textContent = `${Math.max(0, enemyHealth)}/100`;
                
                if (enemyHealth <= 0) {
                    enemyHealth = 0;
                    gameActive = false;
                    document.getElementById('gameover').style.display = 'block';
                    document.getElementById('victory-text').textContent = '‡¶¨‡¶ø‡¶ú‡¶Ø‡¶º‡ßÄ';
                }
            }
        }
        
        function performSpecial() {
            if (!gameActive || specialCooldown || crystalEnergy < 30) return;
            
            specialCooldown = true;
            setTimeout(() => specialCooldown = false, 1000);
            
            crystalEnergy -= 30;
            document.getElementById('crystal-value').textContent = Math.floor(crystalEnergy) + '%';
            
            const distance = player.position.distanceTo(enemy.position);
            if (distance < 5.0) {
                enemyHealth -= 40;
                
                showDamageNumber(40, enemy.position.x, enemy.position.y + 2, enemy.position.z, true);
                
                // ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶¨‡¶ø‡¶∏‡ßç‡¶´‡ßã‡¶∞‡¶£
                crystalLight.intensity = 5;
                crystalLight.color.setHex(0xff00ff);
                
                setTimeout(() => {
                    crystalLight.intensity = 2;
                    crystalLight.color.setHex(0x9c27b0);
                }, 300);
                
                document.getElementById('enemy-health-fill').style.width = Math.max(0, enemyHealth) + '%';
                document.getElementById('enemy-health-value').textContent = `${Math.max(0, enemyHealth)}/100`;
                
                if (enemyHealth <= 0) {
                    enemyHealth = 0;
                    gameActive = false;
                    document.getElementById('gameover').style.display = 'block';
                    document.getElementById('victory-text').textContent = '‡¶¨‡¶ø‡¶ú‡¶Ø‡¶º‡ßÄ';
                }
            }
        }
        
        // ‡¶´‡¶ø‡¶ú‡¶ø‡¶ï‡ßç‡¶∏
        let velocity = new THREE.Vector3();
        let isJumping = false;
        const gravity = 0.02;
        const groundY = 0.5;
        
        // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Æ‡ßá‡¶∂‡¶® ‡¶≤‡ßÅ‡¶™
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive) {
                time += 0.01;
                
                // ‡¶Æ‡ßÅ‡¶≠‡¶Æ‡ßá‡¶®‡ßç‡¶ü
                let moveX = 0;
                let moveZ = 0;
                const speed = 0.12;
                
                if (keys.a) moveX -= speed;
                if (keys.d) moveX += speed;
                if (keys.w) moveZ -= speed;
                if (keys.s) moveZ += speed;
                
                if (moveX !== 0 || moveZ !== 0) {
                    const length = Math.sqrt(moveX*moveX + moveZ*moveZ);
                    moveX = moveX / length * speed;
                    moveZ = moveZ / length * speed;
                }
                
                // ‡¶∏‡ßÄ‡¶Æ‡¶æ ‡¶ö‡ßá‡¶ï
                let newX = player.position.x + moveX;
                let newZ = player.position.z + moveZ;
                const limit = 7;
                
                if (Math.abs(newX) < limit) player.position.x = newX;
                if (Math.abs(newZ) < limit) player.position.z = newZ;
                
                // ‡¶ú‡¶æ‡¶Æ‡ßç‡¶™
                if (keys.space && !isJumping) {
                    velocity.y = 0.3;
                    isJumping = true;
                }
                
                // ‡¶ó‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶≠‡¶ø‡¶ü‡¶ø
                velocity.y -= gravity;
                player.position.y += velocity.y;
                
                if (player.position.y <= groundY) {
                    player.position.y = groundY;
                    velocity.y = 0;
                    isJumping = false;
                }
                
                // ‡¶∞‡ßã‡¶ü‡ßá‡¶∂‡¶®
                if (player.position.distanceTo(enemy.position) > 0.1) {
                    player.lookAt(enemy.position);
                }
                
                // ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶ï
                if (keys.j) performAttack(15, 'light');
                if (keys.k) performAttack(25, 'heavy');
                if (keys.l) performSpecial();
                
                // ‡¶è‡¶®‡¶ø‡¶Æ‡¶ø AI
                const direction = new THREE.Vector3().subVectors(player.position, enemy.position);
                if (direction.length() > 2.8) {
                    direction.normalize();
                    enemy.position.x += direction.x * 0.025;
                    enemy.position.z += direction.z * 0.025;
                }
                
                enemy.lookAt(player.position);
                
                // ‡¶è‡¶®‡¶ø‡¶Æ‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶ï
                if (player.position.distanceTo(enemy.position) < 3.0 && Math.random() < 0.02) {
                    playerHealth -= 10;
                    
                    showDamageNumber(10, player.position.x, player.position.y + 2, player.position.z, false);
                    
                    document.getElementById('player-health-fill').style.width = Math.max(0, playerHealth) + '%';
                    document.getElementById('player-health-value').textContent = `${Math.max(0, playerHealth)}/100`;
                    
                    if (playerHealth <= 0) {
                        playerHealth = 0;
                        gameActive = false;
                        document.getElementById('gameover').style.display = 'block';
                        document.getElementById('victory-text').textContent = '‡¶™‡¶∞‡¶æ‡¶ú‡¶Ø‡¶º';
                    }
                }
                
                // ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶∞‡¶ø‡¶ö‡¶æ‡¶∞‡ßç‡¶ú
                crystalEnergy = Math.min(100, crystalEnergy + 0.1);
                document.getElementById('crystal-value').textContent = Math.floor(crystalEnergy) + '%';
                
                // ‡¶Ü‡¶á‡¶°‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶®‡¶ø‡¶Æ‡ßá‡¶∂‡¶®
                player.position.y = groundY + Math.sin(time * 3) * 0.03;
                enemy.position.y = groundY + Math.sin(time * 3 + 2) * 0.03;
                
                // ‡¶ï‡ßç‡¶∞‡¶ø‡¶∏‡ßç‡¶ü‡¶æ‡¶≤ ‡¶ò‡ßÇ‡¶∞‡ßç‡¶£‡¶®
                const playerCrystal = player.children[10];
                if (playerCrystal) playerCrystal.rotation.y += 0.02;
                if (playerCrystal) playerCrystal.rotation.x += 0.01;
                
                const enemyCrystal = enemy.children[10];
                if (enemyCrystal) enemyCrystal.rotation.y += 0.02;
                
                // ‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø‡¶ï‡ßá‡¶≤ ‡¶Æ‡ßÅ‡¶≠
                particles.rotation.y += 0.001;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // ‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶ú
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
